package org.scalablytyped.converter.internal
package scalajs

import io.circe.*
import io.circe.generic.auto.*
import io.circe.parser.*
import org.scalajs.dom
import org.scalajs.dom.fetch
import scala.util.{Success, Failure}
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.scalajs.js
import scala.scalajs.js.annotation.JSImport

// JSON parsing imports
import org.scalablytyped.converter.internal.{IArray, Json}
import org.scalablytyped.converter.internal.scalajs.Tree
import org.scalajs.dom.fetch

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.scalajs.js
import scala.scalajs.js.Thenable.Implicits.*

// JSON parsing functions
def parseJsonData(jsonString: String): Either[IArray[Tree], IArray[Tree]] = {
  Json.apply[IArray[Tree]](jsonString) match {
    case Left(error) => Left(IArray[Tree]())
    case Right(result) => Right(result)
  }
}

def loadJsonData(url: String): Future[String] = {
  fetch(url)
    .toFuture
    .flatMap(_.text().toFuture)
}

object ScalaJsClasses {
  // format: off
  // this is generated by `ImportScalaDefinitions`
  val precomputed = {
    loadJsonData("/resources/scalajs-definitions.json").flatMap[IArray[Tree]] { jsonString =>
      val result = parseJsonData(jsonString).toOption.getOrElse(IArray[Tree]())
      Future.successful(result)
    }
  }



  val Any =
    ClassTree(
      isImplicit = false,
      Empty,
      ProtectionLevel.Public,
      Name.Object,
      Empty,
      Empty,
      Empty,
      IArray(
        MethodTree(Empty, ProtectionLevel.Public, Name("getClass"), Empty, IArray(IArray()), ExprTree.native, TypeRef(QualifiedName(IArray(Name.java, Name.lang, Name("Class"))), IArray(TypeRef.Wildcard), NoComments), isOverride = false, NoComments, QualifiedName.Any + Name("getClass"), false),
        MethodTree(Empty, ProtectionLevel.Public, Name("hashCode"), Empty, IArray(IArray()), ExprTree.native, TypeRef.Int, isOverride = false, NoComments, QualifiedName.Any + Name("hashCode"), false),
        MethodTree(Empty, ProtectionLevel.Public, Name("eq"), Empty, IArray(IArray(ParamTree(Name("obj"), isImplicit = false, isVal = false, TypeRef.Any, NotImplemented, NoComments))), ExprTree.native, TypeRef.Int, isOverride = false, NoComments, QualifiedName.Any + Name("eq"), false),
        MethodTree(Empty, ProtectionLevel.Public, Name("equals"), Empty, IArray(IArray(ParamTree(Name("obj"), isImplicit = false, isVal = false, TypeRef.Any, NotImplemented, NoComments))), ExprTree.native, TypeRef.Int, isOverride = false, NoComments, QualifiedName.Any + Name("equals"), false),
        MethodTree(Empty, ProtectionLevel.Public, Name("toString"), Empty, IArray(IArray()), ExprTree.native, TypeRef.String, isOverride = false, NoComments, QualifiedName.Any + Name("toString"), false),
        MethodTree(Empty, ProtectionLevel.Public, Name("ne"), Empty, IArray(IArray(ParamTree(Name("obj"), isImplicit = false, isVal = false, TypeRef.Any, NotImplemented, NoComments))), ExprTree.native, TypeRef.Int, isOverride = false, NoComments, QualifiedName.Any + Name("ne"), false),
        MethodTree(Empty, ProtectionLevel.Public, Name("notify"), Empty, IArray(IArray()), ExprTree.native, TypeRef.Unit, isOverride = false, NoComments, QualifiedName.Any + Name("notify"), false),
        MethodTree(Empty, ProtectionLevel.Public, Name("notifyAll"), Empty, IArray(IArray()), ExprTree.native, TypeRef.Unit, isOverride = false, NoComments, QualifiedName.Any + Name("notifyAll"), false),
        MethodTree(Empty, ProtectionLevel.Public, Name("wait"), Empty, IArray(IArray()), ExprTree.native, TypeRef.Unit, isOverride = false, NoComments, QualifiedName.Any + Name("wait"), false),
        MethodTree(Empty, ProtectionLevel.Public, Name("wait"), Empty, IArray(IArray(ParamTree(Name("timeout"), isImplicit = false, isVal = false, TypeRef.Long, NotImplemented, NoComments))), ExprTree.native, TypeRef.Unit, isOverride = false, NoComments, QualifiedName.Any + Name("wait"), false),
        MethodTree(Empty, ProtectionLevel.Public, Name("wait"), Empty, IArray(IArray(ParamTree(Name("timeout"), isImplicit = false, isVal = false, TypeRef.Long, NotImplemented, NoComments), ParamTree(Name("nanos"), isImplicit = false, isVal = false, TypeRef.Int, NotImplemented, NoComments))), ExprTree.native, TypeRef.Unit, isOverride = false, NoComments, QualifiedName.Any + Name("wait"), false),
        MethodTree(Empty, ProtectionLevel.Protected, Name("clone"), Empty, IArray(IArray()), ExprTree.native, TypeRef.Any, isOverride = false, NoComments, QualifiedName.Any + Name("clone"), false),
        MethodTree(Empty, ProtectionLevel.Protected, Name("finalize"), Empty, IArray(IArray()), ExprTree.native, TypeRef.Unit, isOverride = false, NoComments, QualifiedName.Any + Name("finalize"), false),
      ),
      ClassType.Class,
      isSealed = false,
      NoComments,
      QualifiedName.Any,
    )

  val hardcoded: IArray[ClassTree] = {
    def cls(cp: QualifiedName, parents: IArray[TypeRef], classType: ClassType, isSealed: Boolean) =
      ClassTree(false, Empty, ProtectionLevel.Public, cp.parts.last, Empty, parents, Empty, Empty, classType, isSealed, NoComments, cp)

    IArray(
        Any,
        cls(QualifiedName.AnyRef, IArray(TypeRef.Any), ClassType.Trait, isSealed     = false),
        cls(QualifiedName.AnyVal, IArray(TypeRef.Any), ClassType.Trait, isSealed     = false),
        cls(QualifiedName.Boolean, IArray(TypeRef.AnyVal), ClassType.Class, isSealed = true),
        cls(QualifiedName.Byte, IArray(TypeRef.AnyVal), ClassType.Class, isSealed  = true),
        cls(QualifiedName.Double, IArray(TypeRef.AnyVal), ClassType.Class, isSealed  = true),
        cls(QualifiedName("scala.Error"), IArray(TypeRef.AnyRef), ClassType.Class, isSealed  = true),
        cls(QualifiedName.Float, IArray(TypeRef.AnyVal), ClassType.Class, isSealed  = true),
        cls(QualifiedName.Int, IArray(TypeRef.AnyVal), ClassType.Class, isSealed     = true),
        cls(QualifiedName.Long, IArray(TypeRef.AnyVal), ClassType.Class, isSealed     = true),
        cls(QualifiedName.Nothing, IArray(TypeRef.Any), ClassType.Class, isSealed  = true),
        cls(QualifiedName.Null, IArray(TypeRef.AnyRef), ClassType.Trait, isSealed    = false),
        cls(QualifiedName.Short, IArray(TypeRef.AnyVal), ClassType.Class, isSealed  = true),
        cls(QualifiedName.String, IArray(TypeRef.AnyRef), ClassType.Class, isSealed  = true),
        cls(QualifiedName.Unit, IArray(TypeRef.AnyVal), ClassType.Class, isSealed    = true),
        cls(QualifiedName.JsAny, IArray(TypeRef.AnyRef), ClassType.Trait, isSealed   = false),
    )
  }

  val ScalaJsTypes: Map[QualifiedName, Tree] =
    (hardcoded).collect { case x: (Tree & HasCodePath) => x.codePath -> x }.toMap

  val jsObjectMembers: IArray[Tree] = {
    IArray(
      Any,
      ScalaJsTypes(QualifiedName.JsObject),
    ).collect { case x: ClassTree => x.members }.flatten
  }

  val jsObjectMembersByName: Map[Name, IArray[Tree]] =
    jsObjectMembers.groupBy(_.name)
}
