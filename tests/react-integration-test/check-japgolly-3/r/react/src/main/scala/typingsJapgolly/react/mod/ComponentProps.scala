package typingsJapgolly.react.mod

import typingsJapgolly.react.reactStrings.a_
import typingsJapgolly.react.reactStrings.abbr
import typingsJapgolly.react.reactStrings.address
import typingsJapgolly.react.reactStrings.area
import typingsJapgolly.react.reactStrings.article
import typingsJapgolly.react.reactStrings.aside
import typingsJapgolly.react.reactStrings.audio
import typingsJapgolly.react.reactStrings.b
import typingsJapgolly.react.reactStrings.base
import typingsJapgolly.react.reactStrings.bdi
import typingsJapgolly.react.reactStrings.bdo
import typingsJapgolly.react.reactStrings.big
import typingsJapgolly.react.reactStrings.view
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

/**
  * NOTE: prefer ComponentPropsWithRef, if the ref is forwarded,
  * or ComponentPropsWithoutRef when refs are not supported.
  */
/** NOTE: Conditional type definitions are impossible to translate to Scala.
  * See https://www.typescriptlang.org/docs/handbook/2/conditional-types.html for an intro.
  * You'll have to cast your way around this structure, unfortunately.
  * TS definition: {{{
  T extends react.react.JSXElementConstructor<infer P> ? P : T extends 'a' | 'abbr' | 'address' | 'area' | 'article' | 'aside' | 'audio' | 'b' | 'base' | 'bdi' | 'bdo' | 'big' | 'view' ? react.react.<global>.JSX.IntrinsicElements[T] : {}
  }}}
  */
@js.native
trait ComponentProps[T /* <: a_ | abbr | address | area | article | aside | audio | b | base | bdi | bdo | big | view | JSXElementConstructor[Any] */] extends StObject
